#' \code{nameCol} and \code{valueCol} to numeric or to leave as text. Default is to convert to numeric (i.e., TRUE)
#' @param nameCol The name of the column that describes the nature of the value in the \code{valueCol}
#' @param valueCol The name of the column with the values of the properties listed in the \code{nameCol}
reorganizeTable <- function(data, baseName=NA, convertToNumeric=TRUE, nameCol='Measurement', valueCol='Value')
{
require(plyr)
idCols <- names(data)
idCols <- idCols[-which(idCols %in% c(nameCol,valueCol))]
newData <- data.frame(stringsAsFactors=FALSE)
measurements <- unique(data[,nameCol])
for(m in measurements)
{
if(is.na(baseName))
{
newColName <- m
newColName <- gsub(' ','.',newColName, fixed=TRUE) # Get rid of extraneous spaces
}else
{
newColName <- paste(baseName,'.',m, sep='')
newColName <- gsub(' ','.',newColName, fixed=TRUE) # Get rid of extraneous spaces
}
temp <- data[data[,nameCol]==m,]
temp2 <- temp[,c(idCols,valueCol)]
if (length(idCols) == 0) {
temp2 <- data.frame(ReallyRandomNameYo = temp2)
names(temp2) <- newColName
}
else {
names(temp2)[names(temp2) == valueCol] <- newColName
}
if(nrow(newData) == 0)
{
newData <- temp2
}else
{
newData <- merge(newData, temp2, by=idCols)
}
}
if(convertToNumeric)
{
for(n in idCols)
{
newData[,n] <- as.numeric(as.character(newData[,n]))
}
}
return(newData)
}
#' Return information and data for a log frequency sweep with the given parameters
#' @param amplitude numeric
#' @param phaseShift numeric - default=0
#' @param offset numeric - defulat=0
#' @param sin boolean T=sinsoid and F=triangular - default=FALSE
#' @param fi numeric initial frequency of the sweep
#' @param ff numeric final frequency of the sweep
#' @param sweepDurtion numeric
#' @param tAll numeric vector All possible times for this
getSweep <- function(amplitude=1, phaseShift=0, offset=0, sin=FALSE, ti=0, fi=2, ff=0.1, sweepDuration=300, t=seq(0,300,0.05), guess=NULL)
{
tOriginal <- t
t <- t-ti
tf <- sweepDuration
N <- log(ff/fi)/log(2)
R <- N / (tf-ti)
if(is.null(guess))
{
A <- amplitude
phi <- phaseShift
b <- offset
}
else
{
A <- guess['amplitude']
phi <- guess['phaseShift']
b <- guess['offset']
}
offsetInflections <- (  (-1*(phi/(pi/2))) %/% 1  )
nf <- -((4*fi-4*ff)*pi*tf+2*log(ff/fi)*phi)/(log(ff/fi)*pi)
nf <- nf + 1 # for good measure.
ni <- seq(0,nf,1) + offsetInflections
suppressWarnings(inflections <- (log((log(ff/fi)*phi)/(2*fi*pi*tf)+(log(ff/fi)*ni)/(4*fi*tf)+1)*tf)/log(ff/fi))
inflections <- inflections[!is.nan(inflections)]
inflectionNums <- (  seq(0,length(inflections)-1,1) + (  offsetInflections %% 4  )  ) %% 4
startTimeI <- which(inflections >= t[1])[1]
endTimeI <- which(inflections <= t[length(t)])
endTimeI <- endTimeI[length(endTimeI)]
if(is.na(endTimeI))
{
stop(paste(t[length(t)], "is greater than last time of last inflection point. Therefore, there must be an error in fi/ff or tAll as there are inflections guaranteed in during times ti to tf given fi and ff."))
}
inflections <- inflections[startTimeI:endTimeI]
inflectionNums <- inflectionNums[startTimeI:endTimeI]
if(sin)
{
predicted <- A*sin(2*pi*((fi*(-1+2^(R*t)))/(R*log(2))) - phi) + b
v=getDerivative(x=predicted, t=t)
return(list(A=A, t=tOriginal, x=predicted, v=v, inflections=inflections+ti, inflectionNums=inflectionNums))
}
else
{
predicted <- (2*A/pi)*asin(sin(2*pi*((fi*(-1+2^(R*t)))/(R*log(2))) - phi)) + b
v=getDerivative(x=predicted, t=t)
return(list(A=A, t=tOriginal, x=predicted, v=v, inflections=inflections+ti, inflectionNums=inflectionNums))
}
}
ti <- 100
duh <- getSweep(ti=ti, t=seq(ti,300+ti,0.05))
plot(duh$t, duh$v, type='l', xlim=c(ti,300+ti))
ti <- 0
duh <- getSweep(ti=ti, t=seq(ti,300+ti,0.05))
plot(duh$t, duh$v, type='l', xlim=c(ti,300+ti))
library(foreign)
library(plyr)
#' Take an arff file and reorganize it into a more standard 'table' format. Specifically this is used to
#' import an arff file from JEX as JEX uses a column called 'Measurement' to define the type of measurment
#' or property being stored and 'Value', the value of that property.
#'
#' @param data An object that is the result of using foreign::read.arff(file) on an arff file
#' @param baseName An optional basename to add to whatever label is in the \code{nameCol} portion of each row entry
#' @param convertToNumeric An option to convert the columns of information within \code{data} leading up to
#' \code{nameCol} and \code{valueCol} to numeric or to leave as text. Default is to convert to numeric (i.e., TRUE)
#' @param nameCol The name of the column that describes the nature of the value in the \code{valueCol}
#' @param valueCol The name of the column with the values of the properties listed in the \code{nameCol}
reorganizeTable <- function(data, baseName=NA, convertToNumeric=TRUE, nameCol='Measurement', valueCol='Value')
{
require(plyr)
idCols <- names(data)
idCols <- idCols[-which(idCols %in% c(nameCol,valueCol))]
newData <- data.frame(stringsAsFactors=FALSE)
measurements <- unique(data[,nameCol])
for(m in measurements)
{
if(is.na(baseName))
{
newColName <- m
newColName <- gsub(' ','.',newColName, fixed=TRUE) # Get rid of extraneous spaces
}else
{
newColName <- paste(baseName,'.',m, sep='')
newColName <- gsub(' ','.',newColName, fixed=TRUE) # Get rid of extraneous spaces
}
temp <- data[data[,nameCol]==m,]
temp2 <- temp[,c(idCols,valueCol)]
if (length(idCols) == 0) {
temp2 <- data.frame(ReallyRandomNameYo = temp2)
names(temp2) <- newColName
}
else {
names(temp2)[names(temp2) == valueCol] <- newColName
}
if(nrow(newData) == 0)
{
newData <- temp2
}else
{
newData <- merge(newData, temp2, by=idCols)
}
}
if(convertToNumeric)
{
for(n in idCols)
{
newData[,n] <- as.numeric(as.character(newData[,n]))
}
}
return(newData)
}
#' Return information and data for a log frequency sweep with the given parameters
#' @param amplitude numeric
#' @param phaseShift numeric - default=0
#' @param offset numeric - defulat=0
#' @param sin boolean T=sinsoid and F=triangular - default=FALSE
#' @param fi numeric initial frequency of the sweep
#' @param ff numeric final frequency of the sweep
#' @param sweepDurtion numeric
#' @param tAll numeric vector All possible times for this
getSweep <- function(amplitude=1, phaseShift=0, offset=0, sin=FALSE, ti=0, fi=2, ff=0.1, sweepDuration=300, t=seq(0,300,0.05), guess=NULL)
{
tOriginal <- t
t <- t-ti
tf <- sweepDuration
N <- log(ff/fi)/log(2)
R <- N / (tf-ti)
if(is.null(guess))
{
A <- amplitude
phi <- phaseShift
b <- offset
}
else
{
A <- guess['amplitude']
phi <- guess['phaseShift']
b <- guess['offset']
}
browse()
offsetInflections <- (  (-1*(phi/(pi/2))) %/% 1  )
nf <- -((4*fi-4*ff)*pi*tf+2*log(ff/fi)*phi)/(log(ff/fi)*pi)
nf <- nf + 1 # for good measure.
ni <- seq(0,nf,1) + offsetInflections
suppressWarnings(inflections <- (log((log(ff/fi)*phi)/(2*fi*pi*tf)+(log(ff/fi)*ni)/(4*fi*tf)+1)*tf)/log(ff/fi))
inflections <- inflections[!is.nan(inflections)]
inflectionNums <- (  seq(0,length(inflections)-1,1) + (  offsetInflections %% 4  )  ) %% 4
startTimeI <- which(inflections >= t[1])[1]
endTimeI <- which(inflections <= t[length(t)])
endTimeI <- endTimeI[length(endTimeI)]
if(is.na(endTimeI))
{
stop(paste(t[length(t)], "is greater than last time of last inflection point. Therefore, there must be an error in fi/ff or tAll as there are inflections guaranteed in during times ti to tf given fi and ff."))
}
inflections <- inflections[startTimeI:endTimeI]
inflectionNums <- inflectionNums[startTimeI:endTimeI]
if(sin)
{
predicted <- A*sin(2*pi*((fi*(-1+2^(R*t)))/(R*log(2))) - phi) + b
v=getDerivative(x=predicted, t=t)
return(list(A=A, t=tOriginal, x=predicted, v=v, inflections=inflections+ti, inflectionNums=inflectionNums))
}
else
{
predicted <- (2*A/pi)*asin(sin(2*pi*((fi*(-1+2^(R*t)))/(R*log(2))) - phi)) + b
v=getDerivative(x=predicted, t=t)
return(list(A=A, t=tOriginal, x=predicted, v=v, inflections=inflections+ti, inflectionNums=inflectionNums))
}
}
source('~/Public/DropBox/GitHub/R-Adhesion/CellTracking/R/PackageFunctions.R', echo=TRUE)
ti <- 0
duh <- getSweep(ti=ti, t=seq(ti,300+ti,0.05))
plot(duh$t, duh$v, type='l', xlim=c(ti,300+ti))
source('~/Public/DropBox/GitHub/R-Adhesion/CellTracking/R/PackageFunctions.R', echo=TRUE)
ti <- 0
duh <- getSweep(ti=ti, t=seq(ti,300+ti,0.05))
t
tf
N
R
A
phi
b
ti <- 100
duh <- getSweep(ti=ti, t=seq(ti,300+ti,0.05))
t
tf
N
R
library(foreign)
library(plyr)
#' Take an arff file and reorganize it into a more standard 'table' format. Specifically this is used to
#' import an arff file from JEX as JEX uses a column called 'Measurement' to define the type of measurment
#' or property being stored and 'Value', the value of that property.
#'
#' @param data An object that is the result of using foreign::read.arff(file) on an arff file
#' @param baseName An optional basename to add to whatever label is in the \code{nameCol} portion of each row entry
#' @param convertToNumeric An option to convert the columns of information within \code{data} leading up to
#' \code{nameCol} and \code{valueCol} to numeric or to leave as text. Default is to convert to numeric (i.e., TRUE)
#' @param nameCol The name of the column that describes the nature of the value in the \code{valueCol}
#' @param valueCol The name of the column with the values of the properties listed in the \code{nameCol}
reorganizeTable <- function(data, baseName=NA, convertToNumeric=TRUE, nameCol='Measurement', valueCol='Value')
{
require(plyr)
idCols <- names(data)
idCols <- idCols[-which(idCols %in% c(nameCol,valueCol))]
newData <- data.frame(stringsAsFactors=FALSE)
measurements <- unique(data[,nameCol])
for(m in measurements)
{
if(is.na(baseName))
{
newColName <- m
newColName <- gsub(' ','.',newColName, fixed=TRUE) # Get rid of extraneous spaces
}else
{
newColName <- paste(baseName,'.',m, sep='')
newColName <- gsub(' ','.',newColName, fixed=TRUE) # Get rid of extraneous spaces
}
temp <- data[data[,nameCol]==m,]
temp2 <- temp[,c(idCols,valueCol)]
if (length(idCols) == 0) {
temp2 <- data.frame(ReallyRandomNameYo = temp2)
names(temp2) <- newColName
}
else {
names(temp2)[names(temp2) == valueCol] <- newColName
}
if(nrow(newData) == 0)
{
newData <- temp2
}else
{
newData <- merge(newData, temp2, by=idCols)
}
}
if(convertToNumeric)
{
for(n in idCols)
{
newData[,n] <- as.numeric(as.character(newData[,n]))
}
}
return(newData)
}
#' Return information and data for a log frequency sweep with the given parameters
#' @param amplitude numeric
#' @param phaseShift numeric - default=0
#' @param offset numeric - defulat=0
#' @param sin boolean T=sinsoid and F=triangular - default=FALSE
#' @param fi numeric initial frequency of the sweep
#' @param ff numeric final frequency of the sweep
#' @param sweepDurtion numeric
#' @param tAll numeric vector All possible times for this
getSweep <- function(amplitude=1, phaseShift=0, offset=0, sin=FALSE, ti=0, fi=2, ff=0.1, sweepDuration=300, t=seq(0,300,0.05), guess=NULL)
{
tOriginal <- t
t <- t-ti
tf <- sweepDuration
N <- log(ff/fi)/log(2)
R <- N / (sweepDuration) # Usually tf-ti but time adjusting t by ti
if(is.null(guess))
{
A <- amplitude
phi <- phaseShift
b <- offset
}
else
{
A <- guess['amplitude']
phi <- guess['phaseShift']
b <- guess['offset']
}
browser()
offsetInflections <- (  (-1*(phi/(pi/2))) %/% 1  )
nf <- -((4*fi-4*ff)*pi*tf+2*log(ff/fi)*phi)/(log(ff/fi)*pi)
nf <- nf + 1 # for good measure.
ni <- seq(0,nf,1) + offsetInflections
suppressWarnings(inflections <- (log((log(ff/fi)*phi)/(2*fi*pi*tf)+(log(ff/fi)*ni)/(4*fi*tf)+1)*tf)/log(ff/fi))
inflections <- inflections[!is.nan(inflections)]
inflectionNums <- (  seq(0,length(inflections)-1,1) + (  offsetInflections %% 4  )  ) %% 4
startTimeI <- which(inflections >= t[1])[1]
endTimeI <- which(inflections <= t[length(t)])
endTimeI <- endTimeI[length(endTimeI)]
if(is.na(endTimeI))
{
stop(paste(t[length(t)], "is greater than last time of last inflection point. Therefore, there must be an error in fi/ff or tAll as there are inflections guaranteed in during times ti to tf given fi and ff."))
}
inflections <- inflections[startTimeI:endTimeI]
inflectionNums <- inflectionNums[startTimeI:endTimeI]
if(sin)
{
predicted <- A*sin(2*pi*((fi*(-1+2^(R*t)))/(R*log(2))) - phi) + b
v=getDerivative(x=predicted, t=t)
return(list(A=A, t=tOriginal, x=predicted, v=v, inflections=inflections+ti, inflectionNums=inflectionNums))
}
else
{
predicted <- (2*A/pi)*asin(sin(2*pi*((fi*(-1+2^(R*t)))/(R*log(2))) - phi)) + b
v=getDerivative(x=predicted, t=t)
return(list(A=A, t=tOriginal, x=predicted, v=v, inflections=inflections+ti, inflectionNums=inflectionNums))
}
}
ti <- 100
duh <- getSweep(ti=ti, t=seq(ti,300+ti,0.05))
library(foreign)
library(plyr)
#' Take an arff file and reorganize it into a more standard 'table' format. Specifically this is used to
#' import an arff file from JEX as JEX uses a column called 'Measurement' to define the type of measurment
#' or property being stored and 'Value', the value of that property.
#'
#' @param data An object that is the result of using foreign::read.arff(file) on an arff file
#' @param baseName An optional basename to add to whatever label is in the \code{nameCol} portion of each row entry
#' @param convertToNumeric An option to convert the columns of information within \code{data} leading up to
#' \code{nameCol} and \code{valueCol} to numeric or to leave as text. Default is to convert to numeric (i.e., TRUE)
#' @param nameCol The name of the column that describes the nature of the value in the \code{valueCol}
#' @param valueCol The name of the column with the values of the properties listed in the \code{nameCol}
reorganizeTable <- function(data, baseName=NA, convertToNumeric=TRUE, nameCol='Measurement', valueCol='Value')
{
require(plyr)
idCols <- names(data)
idCols <- idCols[-which(idCols %in% c(nameCol,valueCol))]
newData <- data.frame(stringsAsFactors=FALSE)
measurements <- unique(data[,nameCol])
for(m in measurements)
{
if(is.na(baseName))
{
newColName <- m
newColName <- gsub(' ','.',newColName, fixed=TRUE) # Get rid of extraneous spaces
}else
{
newColName <- paste(baseName,'.',m, sep='')
newColName <- gsub(' ','.',newColName, fixed=TRUE) # Get rid of extraneous spaces
}
temp <- data[data[,nameCol]==m,]
temp2 <- temp[,c(idCols,valueCol)]
if (length(idCols) == 0) {
temp2 <- data.frame(ReallyRandomNameYo = temp2)
names(temp2) <- newColName
}
else {
names(temp2)[names(temp2) == valueCol] <- newColName
}
if(nrow(newData) == 0)
{
newData <- temp2
}else
{
newData <- merge(newData, temp2, by=idCols)
}
}
if(convertToNumeric)
{
for(n in idCols)
{
newData[,n] <- as.numeric(as.character(newData[,n]))
}
}
return(newData)
}
#' Return information and data for a log frequency sweep with the given parameters
#' @param amplitude numeric
#' @param phaseShift numeric - default=0
#' @param offset numeric - defulat=0
#' @param sin boolean T=sinsoid and F=triangular - default=FALSE
#' @param fi numeric initial frequency of the sweep
#' @param ff numeric final frequency of the sweep
#' @param sweepDurtion numeric
#' @param tAll numeric vector All possible times for this
getSweep <- function(amplitude=1, phaseShift=0, offset=0, sin=FALSE, ti=0, fi=2, ff=0.1, sweepDuration=300, t=seq(0,300,0.05), guess=NULL)
{
tOriginal <- t
t <- t-ti
tf <- sweepDuration
N <- log(ff/fi)/log(2)
R <- N / (sweepDuration) # Usually tf-ti but time adjusting t by ti
if(is.null(guess))
{
A <- amplitude
phi <- phaseShift
b <- offset
}
else
{
A <- guess['amplitude']
phi <- guess['phaseShift']
b <- guess['offset']
}
offsetInflections <- (  (-1*(phi/(pi/2))) %/% 1  )
nf <- -((4*fi-4*ff)*pi*tf+2*log(ff/fi)*phi)/(log(ff/fi)*pi)
nf <- nf + 1 # for good measure.
ni <- seq(0,nf,1) + offsetInflections
suppressWarnings(inflections <- (log((log(ff/fi)*phi)/(2*fi*pi*tf)+(log(ff/fi)*ni)/(4*fi*tf)+1)*tf)/log(ff/fi))
inflections <- inflections[!is.nan(inflections)]
inflectionNums <- (  seq(0,length(inflections)-1,1) + (  offsetInflections %% 4  )  ) %% 4
startTimeI <- which(inflections >= t[1])[1]
endTimeI <- which(inflections <= t[length(t)])
endTimeI <- endTimeI[length(endTimeI)]
if(is.na(endTimeI))
{
stop(paste(t[length(t)], "is greater than last time of last inflection point. Therefore, there must be an error in fi/ff or tAll as there are inflections guaranteed in during times ti to tf given fi and ff."))
}
inflections <- inflections[startTimeI:endTimeI]
inflectionNums <- inflectionNums[startTimeI:endTimeI]
if(sin)
{
predicted <- A*sin(2*pi*((fi*(-1+2^(R*t)))/(R*log(2))) - phi) + b
v=getDerivative(x=predicted, t=t)
return(list(A=A, t=tOriginal, x=predicted, v=v, inflections=inflections+ti, inflectionNums=inflectionNums))
}
else
{
predicted <- (2*A/pi)*asin(sin(2*pi*((fi*(-1+2^(R*t)))/(R*log(2))) - phi)) + b
v=getDerivative(x=predicted, t=t)
return(list(A=A, t=tOriginal, x=predicted, v=v, inflections=inflections+ti, inflectionNums=inflectionNums))
}
}
source('~/Public/DropBox/GitHub/R-Adhesion/CellTracking/R/PackageFunctions.R', echo=TRUE)
ti <- 100
duh <- getSweep(ti=ti, t=seq(ti,300+ti,0.05))
plot(duh$t, duh$v, type='l', xlim=c(ti,300+ti))
ti <- 0
duh <- getSweep(ti=ti, t=seq(ti,300+ti,0.05))
plot(duh$t, duh$v, type='l', xlim=c(ti,300+ti))
bestFit <- getBulkPhaseShift(trackList, tiGuess=0)
fitCurveData <- getSweep(amplitude=bestFit$par[['amplitude']], phaseShift=bestFit$par[['phaseShift']], sweepDuration=(1/bestFit$par[['timeScalingFactor']])*trackList$sweepDuration, offset=0, sin=trackList$sin, ti=0, fi=trackList$fi, ff=trackList$ff, t=trackList$tAll, guess=NULL)
trackList$plotTrackList(slot='vx', rel=TRUE, ylim=c(-500,500), validOnly=FALSE, xlim=c(0,5))
lines(fitCurveData$t, fitCurveData$v, col='red')
trackList$plotTrackList(slot='vx', rel=TRUE, ylim=c(-50,50), validOnly=FALSE, xlim=c(125,300))
lines(fitCurveData$t, fitCurveData$v, col='red')
fitCurveData <- getSweep(amplitude=bestFit$par[['amplitude']], phaseShift=bestFit$par[['phaseShift']], sweepDuration=(1/bestFit$par[['timeScalingFactor']])*trackList$sweepDuration, offset=0, sin=trackList$sin, ti=bestFit$par[['ti']], fi=trackList$fi, ff=trackList$ff, t=trackList$tAll, guess=NULL)
trackList$plotTrackList(slot='vx', rel=TRUE, ylim=c(-500,500), validOnly=FALSE, xlim=c(0,5))
lines(fitCurveData$t, fitCurveData$v, col='red')
trackList$plotTrackList(slot='vx', rel=TRUE, ylim=c(-50,50), validOnly=FALSE, xlim=c(125,300))
lines(fitCurveData$t, fitCurveData$v, col='red')
300*0.9998993
.035/0.035001
.035/0.03501
results = trackList$getPercentAdhered(velocityThreshold=5)
plot(results$time, results$percentAdhered, xlab='Time [s]', ylab='Percent Adhered [%]')
source('~/Public/DropBox/GitHub/R-Adhesion/CellTracking/R/TrackFitting.R', echo=TRUE)
bestFit <- getBulkPhaseShift(trackList, tiGuess=0)
fitCurveData <- getSweep(amplitude=bestFit$par[['amplitude']], phaseShift=bestFit$par[['phaseShift']], sweepDuration=(1/bestFit$par[['timeScalingFactor']])*trackList$sweepDuration, offset=0, sin=trackList$sin, ti=bestFit$par[['ti']], fi=trackList$fi, ff=trackList$ff, t=trackList$tAll, guess=NULL)
trackList$plotTrackList(slot='vx', rel=TRUE, ylim=c(-500,500), validOnly=FALSE, xlim=c(0,5))
lines(fitCurveData$t, fitCurveData$v, col='red')
trackList$plotTrackList(slot='vx', rel=TRUE, ylim=c(-50,50), validOnly=FALSE, xlim=c(125,300))
lines(fitCurveData$t, fitCurveData$v, col='red')
source('~/Public/DropBox/GitHub/R-Adhesion/CellTracking/R/TrackFitting.R', echo=TRUE)
source('~/Public/DropBox/GitHub/R-Adhesion/CellTracking/R/TrackFitting.R', echo=TRUE)
bestFit <- getBulkPhaseShift(trackList, tiGuess=0)
fitCurveData <- getSweep(amplitude=bestFit$par[['amplitude']], phaseShift=bestFit$par[['phaseShift']], sweepDuration=(1/bestFit$par[['timeScalingFactor']])*trackList$sweepDuration, offset=0, sin=trackList$sin, ti=bestFit$par[['ti']], fi=trackList$fi, ff=trackList$ff, t=trackList$tAll, guess=NULL)
trackList$plotTrackList(slot='vx', rel=TRUE, ylim=c(-500,500), validOnly=FALSE, xlim=c(0,5))
lines(fitCurveData$t, fitCurveData$v, col='red')
trackList$plotTrackList(slot='vx', rel=TRUE, ylim=c(-50,50), validOnly=FALSE, xlim=c(125,300))
lines(fitCurveData$t, fitCurveData$v, col='red')
#fitCurveData <- getSweep(amplitude=150, phaseShift=bestFit$par[['phaseShift']], offset=0, sin=trackList$sin, fi=trackList$fi, ff=trackList$ff, sweepDuration=trackList$sweepDuration, tAll=trackList$tAll, frames=-1, guess=NULL)
